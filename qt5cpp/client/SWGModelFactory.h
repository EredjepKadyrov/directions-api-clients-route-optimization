/**
 * Route Optimization API
 * Our Route Optimization API solves the so called vehicle routing problem fast. It calculates an optimal tour for a set of vehicles, services and constraints
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#ifndef ModelFactory_H_
#define ModelFactory_H_


#include "SWGActivity.h"
#include "SWGAddress.h"
#include "SWGAlgorithm.h"
#include "SWGBreak.h"
#include "SWGCostMatrix.h"
#include "SWGJobId.h"
#include "SWGObjective.h"
#include "SWGRelation.h"
#include "SWGRequest.h"
#include "SWGResponse.h"
#include "SWGRoute.h"
#include "SWGService.h"
#include "SWGShipment.h"
#include "SWGSolution.h"
#include "SWGSolution_unassigned.h"
#include "SWGStop.h"
#include "SWGTimeWindow.h"
#include "SWGVehicle.h"
#include "SWGVehicleType.h"

namespace Swagger {
  inline void* create(QString type) {
    if(QString("SWGActivity").compare(type) == 0) {
      return new SWGActivity();
    }
    if(QString("SWGAddress").compare(type) == 0) {
      return new SWGAddress();
    }
    if(QString("SWGAlgorithm").compare(type) == 0) {
      return new SWGAlgorithm();
    }
    if(QString("SWGBreak").compare(type) == 0) {
      return new SWGBreak();
    }
    if(QString("SWGCostMatrix").compare(type) == 0) {
      return new SWGCostMatrix();
    }
    if(QString("SWGJobId").compare(type) == 0) {
      return new SWGJobId();
    }
    if(QString("SWGObjective").compare(type) == 0) {
      return new SWGObjective();
    }
    if(QString("SWGRelation").compare(type) == 0) {
      return new SWGRelation();
    }
    if(QString("SWGRequest").compare(type) == 0) {
      return new SWGRequest();
    }
    if(QString("SWGResponse").compare(type) == 0) {
      return new SWGResponse();
    }
    if(QString("SWGRoute").compare(type) == 0) {
      return new SWGRoute();
    }
    if(QString("SWGService").compare(type) == 0) {
      return new SWGService();
    }
    if(QString("SWGShipment").compare(type) == 0) {
      return new SWGShipment();
    }
    if(QString("SWGSolution").compare(type) == 0) {
      return new SWGSolution();
    }
    if(QString("SWGSolution_unassigned").compare(type) == 0) {
      return new SWGSolution_unassigned();
    }
    if(QString("SWGStop").compare(type) == 0) {
      return new SWGStop();
    }
    if(QString("SWGTimeWindow").compare(type) == 0) {
      return new SWGTimeWindow();
    }
    if(QString("SWGVehicle").compare(type) == 0) {
      return new SWGVehicle();
    }
    if(QString("SWGVehicleType").compare(type) == 0) {
      return new SWGVehicleType();
    }
    
    return nullptr;
  }

  inline void* create(QString json, QString type) {
    void* val = create(type);
    if(val != nullptr) {
      SWGObject* obj = static_cast<SWGObject*>(val);
      return obj->fromJson(json);
    }
    if(type.startsWith("QString")) {
      return new QString();
    }
    return nullptr;
  }
} /* namespace Swagger */

#endif /* ModelFactory_H_ */
